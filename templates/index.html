<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>AI Agent Controller</title>
</head>
<body>
{% extends "layout.html" %}

{% block content %}
<div class="column column-left" id="main-left-column">
    <!-- TABS HEADER -->
    <div style="display: flex; background-color: #1e1e1e; border-bottom: 1px solid #444;">
        <button id="tab-execution" style="flex: 1; padding: 8px; background: #2a2a2d; color: white; border: none; border-bottom: 2px solid #4CAF50; cursor: pointer; font-size: 14px;">Execution Control</button>
        <button id="tab-chat" style="flex: 1; padding: 8px; background: transparent; color: #aaa; border: none; cursor: pointer; font-size: 14px;">Assistant Chat</button>
    </div>

    <!-- VIEW 1: EXECUTION CONTROL (Existing content wrapped in ID) -->
    <div id="view-execution" class="section" style="border-top: none; display: flex; flex-direction: column;">
        <h2>Objective</h2>
        <textarea id="objective-textarea" placeholder="Enter your high-level objective here..."></textarea>

        <!-- Existing Execution Config & Controls -->
        <div style="margin-top: 10px; display: grid; grid-template-columns: 1fr 1fr; gap: 10px 20px; color: #c0c0c0; background-color: #1e1e1e; padding: 10px; border-radius: 4px; border: 1px solid #444;">
            <strong style="grid-column: 1 / 2;">Execution:</strong>
            <strong style="grid-column: 2 / 3;">Summarization:</strong>

            <label style="cursor: pointer;"><input type="radio" name="execution_mode" value="independent" checked> Independent</label>
            <label style="cursor: pointer;"><input type="radio" name="summarization_mode" value="automatic" checked> Automatic</label>
            <label style="cursor: pointer;"><input type="radio" name="execution_mode" value="assisted"> Assisted</label>
            <label style="cursor: pointer;"><input type="radio" name="summarization_mode" value="assisted"> Assisted</label>

            <strong style="grid-column: 1 / 2; margin-top: 10px;">Interaction & Safety:</strong>
            <strong style="grid-column: 2 / 3; margin-top: 10px;">Command Timeout:</strong>

            <div style="grid-column: 1 / 2; display: flex; flex-direction: column; gap: 5px;">
                <label style="cursor: pointer;">
                    <input type="checkbox" id="allow-ask-checkbox" name="allow_ask" value="true"> Allow Agent to Ask
                </label>
                <label style="cursor: pointer;">
                    <input type="checkbox" id="validator-checkbox" name="validator_enabled" value="true" checked> Enable Validator
                </label>
            </div>
            <div style="grid-column: 2 / 3; display: flex; align-items: center; gap: 5px;">
                <input type="number" id="command-timeout-input" min="10" max="600" value="120" style="width: 60px; padding: 2px 5px; background: #2a2a2a; color: #c0c0c0; border: 1px solid #444; border-radius: 3px;">
                <span style="font-size: 0.9em;">seconds</span>
                <button id="update-timeout-btn" style="padding: 2px 8px; font-size: 0.85em; background-color: #4CAF50; border: none; color: white; border-radius: 3px; cursor: pointer;">Update</button>
                <span id="timeout-countdown" style="font-size: 0.9em; color: #f39c12; margin-left: 5px;"></span>
            </div>
        </div>

        <div class="controls">
            <button id="execute-button">Execute Task</button>
            <button id="pause-button" style="display: none; background-color: #e67e22;">Pause</button>
            <button id="stop-button" style="display: none; background-color: #c0392b;">Stop Task</button>
        </div>
    </div>

    <!-- VIEW 2: CHAT INTERFACE (New) -->
    <div id="view-chat" class="section" style="border-top: none; padding: 0;">

        <!-- Fixed Header (Action Plan Status + Buttons) -->
        <div class="chat-header">
            <div class="chat-header-title">
                <i class="fa-solid fa-robot" style="color: #2196F3;"></i>
                <button id="action-plan-status-btn" class="header-btn" style="font-size: 12px; padding: 4px 10px;" title="Click to view or create action plan">
                    <i class="fa-solid fa-list-check" style="margin-right: 5px;"></i>
                    Plan: <span id="action-plan-status-text" style="margin-left: 3px;">No active plan</span>
                </button>
                <span id="chat-typing-indicator" style="display:none; color: #4CAF50; font-size: 12px; margin-left: 10px;">
                    <i class="fa-solid fa-circle-notch fa-spin"></i> Thinking...
                </span>
            </div>

            <div class="chat-header-actions">
                <label class="header-btn" style="cursor: pointer; display: flex; align-items: center; gap: 5px;" title="Automatically accept task proposals from chat">
                    <input type="checkbox" id="auto-accept-tasks-checkbox" style="margin: 0;">
                    <span>Auto-Accept</span>
                </label>
                <button class="header-btn" id="clear-chat-btn" title="Clear Chat History">
                    <i class="fa-solid fa-trash"></i> Clear
                </button>
                <button class="header-btn" id="chat-fullscreen-btn" title="Toggle Fullscreen">
                    <i class="fa-solid fa-expand"></i> Fullscreen
                </button>
            </div>
        </div>

        <!-- Chat History Container (Scrollable, fills remaining space) -->
        <div id="chat-history-container">
            <div id="chat-history">
                <div id="chat-greeting" style="color: #666; text-align: center; margin-top: 20px;">
                    <p>Chat with the agent about executed tasks.</p>
                </div>
            </div>

            <!-- Task Proposal Area (Hidden by default) -->
            <div id="task-proposal-area" style="display: none; background-color: #2d2d30; border: 1px solid #f39c12; padding: 10px; margin-top: 10px; border-radius: 4px;">
                <strong style="color: #f39c12;">Task Proposal:</strong>
                <p id="proposal-text" style="margin: 5px 0; color: white;">Agent wants to...</p>
                <div style="display: flex; gap: 10px;">
                    <button id="accept-proposal-btn" style="background-color: #4CAF50; padding: 5px;">Set Objective & Go to Execute</button>
                    <button id="reject-proposal-btn" style="background-color: #c0392b; padding: 5px;">Cancel</button>
                </div>
            </div>
        </div>

        <!-- Draggable Resizer Handle -->
        <div id="chat-resizer-handle">
            <div class="resizer-grip"></div>
        </div>

        <!-- Input Container (Resizable) -->
        <div id="chat-input-container">
            <!-- Input Wrapper (Textarea + Button Container) -->
            <div class="chat-input-wrapper">
                <textarea id="chat-input" placeholder="Type your message... (Drag bar above to resize)"></textarea>

                <div class="chat-btn-container">
                    <button id="send-chat-btn">
                        <i class="fa-solid fa-paper-plane"></i> Send
                    </button>
                </div>
            </div>
        </div>

    </div>

    <!-- LOG SECTION (Shared) -->
    <div class="section is-flexible">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
            <h2 style="margin: 0;">Agent Execution Log (Live)</h2>
            <div style="display: flex; gap: 5px;">
                <button id="mode-actions-btn" style="padding: 4px 12px; font-size: 0.85em; background-color: #4CAF50; border: none; color: white; border-radius: 3px; cursor: pointer;">Actions</button>
                <button id="mode-commands-btn" style="padding: 4px 12px; font-size: 0.85em; background-color: #555; border: none; color: white; border-radius: 3px; cursor: pointer;">Commands</button>
                <button id="log-fullscreen-btn" style="background: transparent; border: 1px solid #444; color: #aaa; padding: 2px 6px; font-size: 14px; cursor: pointer; line-height: 1; width: auto;" title="Toggle Fullscreen">&#x26F6;</button>
            </div>
        </div>
        <textarea id="log-textarea" readonly></textarea>
        <div id="execution-status" style="padding: 5px; color: #f39c12; font-family: monospace; font-size: 0.9em; min-height: 20px; border-top: 1px solid #333; background-color: #1e1e1e;"></div>
    </div>
</div>
<div class="column column-right" id="main-right-column">
    <div class="section is-flexible" id="vm-screen">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
            <h2 style="margin: 0;">Remote System Screen (Live)</h2>
            <button id="screen-fullscreen-btn" style="background: transparent; border: 1px solid #444; color: #aaa; padding: 2px 6px; font-size: 14px; cursor: pointer; line-height: 1; width: auto;" title="Toggle Fullscreen">&#x26F6;</button>
        </div>
        <textarea id="vm-textarea" readonly></textarea>
    </div>
</div>
<!-- History & Reports Overlay (Fullscreen) -->
<div id="history-overlay" style="display: none; position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; z-index: 25000; background-color: #121212; overflow: hidden;">
    <div style="display: flex; flex-direction: column; height: 100%; padding: 20px; box-sizing: border-box;">
        <!-- Close Button -->
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
            <h1 style="margin: 0; color: #7aa5d2; font-size: 24px;">History & Reports</h1>
            <button id="close-history-overlay" style="background-color: #c0392b; color: white; border: none; padding: 8px 20px; border-radius: 4px; cursor: pointer; font-size: 16px; font-weight: bold;">
                ✕ Close
            </button>
        </div>

        <!-- History Content (from history.html) -->
        <div class="column" style="flex: 1; overflow: hidden; padding: 0;">
            <div class="section is-flexible">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <h2 style="margin: 0;">Agent Memory</h2>
                        <div style="display: flex; gap: 5px;">
                            <button id="view-llm-context-btn" style="padding: 4px 12px; font-size: 0.85em; background-color: #4CAF50; border: none; color: white; border-radius: 3px; cursor: pointer;">LLM Context</button>
                            <button id="view-full-log-btn" style="padding: 4px 12px; font-size: 0.85em; background-color: #555; border: none; color: white; border-radius: 3px; cursor: pointer;">Full Log</button>
                        </div>
                    </div>
                    <div style="display: flex; gap: 5px; align-items: center;">
                        <input type="text" id="search-input" placeholder="Search logs..." style="padding: 5px 10px; background: #2a2a2a; color: #c0c0c0; border: 1px solid #444; border-radius: 3px; width: 200px;">
                        <button id="search-btn" style="padding: 5px 10px; font-size: 0.85em; background-color: #2196F3; border: none; color: white; border-radius: 3px; cursor: pointer;">Search</button>
                        <button id="refresh-history-btn" style="padding: 5px 10px; font-size: 0.85em; background-color: #4CAF50; border: none; color: white; border-radius: 3px; cursor: pointer;">Refresh</button>
                    </div>
                </div>
                <div class="controls">
                    <button id="edit-history-button" style="background-color: #3b5998;">Edit Agent Memory</button>
                    <button id="reset-button" style="background-color: #9c0e35;">Reset Agent Memory</button>
                    <button id="debug-button" style="background-color: #5c5c5c;">Toggle Debug View</button>
                </div>
                <textarea id="history-textarea" readonly style="margin-top: 10px;"></textarea>
                <div id="search-results" style="margin-top: 10px; padding: 15px; background: #1e1e1e; border: 2px solid #f39c12; border-radius: 5px; display: none;">
                    <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 10px;">
                        <h3 style="margin: 0; color: #4CAF50;">Search Results</h3>
                        <div id="execution-paused-warning" style="display: none; padding: 5px 10px; background-color: #e67e22; color: white; border-radius: 3px; font-size: 0.85em;">
                            Execution paused - waiting for your decision
                        </div>
                    </div>
                    <div id="search-loading" style="display: none; text-align: center; padding: 20px; color: #aaa;">
                        <span>Searching...</span>
                    </div>
                    <div id="search-results-container" style="max-height: 400px; overflow-y: auto; margin-bottom: 10px;">
                        <pre id="search-results-content" style="color: #c0c0c0; white-space: pre-wrap; word-wrap: break-word; margin: 0;"></pre>
                    </div>
                    <div style="display: flex; gap: 10px;">
                        <button id="add-to-context-btn" style="flex: 1; background-color: #4CAF50; padding: 8px 15px;">Add to Context</button>
                        <button id="close-search-results-btn" style="flex: 1; background-color: #c0392b; padding: 8px 15px;">Close</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Raw LLM Modal (from history.html) -->
    <div id="raw-llm-modal-overlay" class="modal-overlay"></div>
    <div id="raw-llm-modal" class="modal-content">
        <span class="modal-close-btn" data-modal-id="raw-llm">&times;</span>
        <h2>Raw LLM Responses</h2>
        <textarea id="raw-llm-textarea" readonly></textarea>
    </div>

    <!-- Edit History Modal (from history.html) -->
    <div id="edit-history-modal-overlay" class="modal-overlay"></div>
    <div id="edit-history-modal" class="modal-content" style="width: 70vw; height: 70vh;">
        <span class="modal-close-btn" data-modal-id="edit-history">&times;</span>
        <h2>Edit Agent Persistent Memory</h2>
        <div style="display: flex; flex-direction: column; height: 100%; padding-top: 10px;">
            <textarea id="edit-history-textarea" style="flex-grow: 1; margin-bottom: 10px; resize: none;"></textarea>
            <button id="save-history-button" style="width: auto; align-self: flex-end; background-color: #4CAF50; margin-top: 10px;">Save Changes</button>
        </div>
    </div>

    <!-- Manual Search Modal (from history.html) -->
    <div id="manual-search-modal-overlay" class="modal-overlay"></div>
    <div id="manual-search-modal" class="modal-content" style="width: 500px;">
        <span class="modal-close-btn" data-modal-id="manual-search">&times;</span>
        <h2 style="color: #2196F3;">Search Execution History</h2>

        <div style="margin-bottom: 15px;">
            <label style="display: block; color: #aaa; margin-bottom: 5px;">Search Query (Keywords):</label>
            <input type="text" id="modal-search-query" placeholder="e.g. error, password, /etc/config" style="width: 100%; padding: 10px; background: #1e1e1e; border: 1px solid #555; color: white; border-radius: 4px;">
        </div>

        <div style="margin-bottom: 20px;">
            <label style="display: block; color: #aaa; margin-bottom: 5px;">Reason / Context (Optional but recommended):</label>
            <textarea id="modal-search-reason" placeholder="Why are you searching? (e.g. To find why the web server failed)" style="width: 100%; height: 80px; padding: 10px; background: #1e1e1e; border: 1px solid #555; color: white; border-radius: 4px; resize: none;"></textarea>
            <p style="font-size: 12px; color: #666; margin-top: 5px;">Providing a reason helps the AI summarize the results more relevantly.</p>
        </div>

        <button id="perform-search-btn" style="background-color: #2196F3; width: 100%;">Search Logs</button>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
document.addEventListener('DOMContentLoaded', () => {
    // --- Referinte elemente UI ---
    const executeButton = document.getElementById('execute-button');
    const stopButton = document.getElementById('stop-button');
    const pauseButton = document.getElementById('pause-button');
    const objectiveTextarea = document.getElementById('objective-textarea');
    const logTextarea = document.getElementById('log-textarea');
    const vmTextarea = document.getElementById('vm-textarea');
    const executionModeRadios = document.querySelectorAll('input[name="execution_mode"]');
    const summarizationModeRadios = document.querySelectorAll('input[name="summarization_mode"]');
    const allowAskCheckbox = document.getElementById('allow-ask-checkbox');
    const validatorCheckbox = document.getElementById('validator-checkbox'); // NEW
    const modeActionsBtn = document.getElementById('mode-actions-btn');
    const modeCommandsBtn = document.getElementById('mode-commands-btn');

    // Log viewing mode: 'actions' or 'commands'
    let logViewMode = sessionStorage.getItem('logViewMode') || 'actions';

    // Full log storage for filtering
    let fullLogContent = '';

    // --- Functii Helper ---

    /**
     * Update mode switcher button styles
     */
    const updateModeButtons = () => {
        if (logViewMode === 'actions') {
            modeActionsBtn.style.backgroundColor = '#4CAF50';
            modeCommandsBtn.style.backgroundColor = '#555';
        } else {
            modeActionsBtn.style.backgroundColor = '#555';
            modeCommandsBtn.style.backgroundColor = '#4CAF50';
        }
    };

    /**
     * Load execution log from backend based on current mode
     */
    const loadExecutionLog = async () => {
        try {
            // For now, we'll use the initial_state event data
            // Backend doesn't have separate actions/commands endpoints yet
            // So we'll filter client-side for now
            return fullLogContent;
        } catch (error) {
            console.error('Error loading execution log:', error);
            return 'Error loading execution log. Please try again.';
        }
    };

    /**
     * Filter log content based on current view mode
     */
    const filterLogByMode = (content) => {
        if (!content) return '';

        const lines = content.split('\n');
        let filteredLines = [];

        if (logViewMode === 'commands') {
            // Commands mode: show clean command list
            // Format: STEP 1: command, STEP 2: command, etc.
            let inNewTask = false;
            let currentStep = null;

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();

                // Detect task boundaries
                if (line.includes('=== NEW TASK ===') || line.includes('Objective:')) {
                    if (!inNewTask) {
                        filteredLines.push('=== NEW TASK ===');
                        inNewTask = true;
                    }
                }
                // Detect step number
                else if (line.startsWith('--- STEP ')) {
                    const stepMatch = line.match(/--- STEP (\d+)/);
                    if (stepMatch) {
                        currentStep = stepMatch[1];
                    }
                }
                // Extract command that was executed
                else if (currentStep && line.startsWith('Executing Command:')) {
                    const command = line.replace('Executing Command:', '').trim();
                    if (command) {
                        filteredLines.push(`STEP ${currentStep}: ${command}`);
                        currentStep = null; // Reset after finding command
                    }
                }
                // Detect task end
                else if (line.includes('REPORT:') || line.includes('=== TASK END ===')) {
                    if (inNewTask) {
                        filteredLines.push('=== TASK END ===');
                        filteredLines.push('');
                        inNewTask = false;
                    }
                }
            }
        } else {
            // Actions mode: show status messages
            const actionKeywords = [
                'Thinking...', 'Validating command', 'Command executed',
                'Command rejected', 'Starting', 'Task finished',
                'Report generated', 'Auto-Validated', 'Auto-Rejected',
                'ERROR:', 'CRITICAL:', 'Timeout:', 'EXECUTION PAUSED',
                'EXECUTION RESUMED', 'Retry'
            ];

            for (const line of lines) {
                const trimmed = line.trim();
                if (actionKeywords.some(keyword => trimmed.includes(keyword))) {
                    filteredLines.push(trimmed);
                }
            }
        }

        return filteredLines.join('\n');
    };

    /**
     * Apply current mode filter to displayed log
     */
    const applyModeFilter = () => {
        logTextarea.value = filterLogByMode(fullLogContent);
        logTextarea.scrollTop = logTextarea.scrollHeight;
    };

    /**
     * Seteaza starea controalelor (disabled/enabled)
     * @param {boolean} disabled - True pentru a dezactiva, false pentru a activa
     */
    const setControlsDisabled = (disabled) => {
        executionModeRadios.forEach(radio => {
            radio.disabled = disabled;
            radio.parentElement.style.color = disabled ? '#666' : '#c0c0c0';
            radio.parentElement.style.cursor = disabled ? 'not-allowed' : 'pointer';
        });
        summarizationModeRadios.forEach(radio => {
            radio.disabled = disabled;
            radio.parentElement.style.color = disabled ? '#666' : '#c0c0c0';
            radio.parentElement.style.cursor = disabled ? 'not-allowed' : 'pointer';
        });
        if (allowAskCheckbox) {
            allowAskCheckbox.disabled = disabled;
            allowAskCheckbox.parentElement.style.color = disabled ? '#666' : '#c0c0c0';
            allowAskCheckbox.parentElement.style.cursor = disabled ? 'not-allowed' : 'pointer';
        }
        // NEW: Handle Validator checkbox
        if (validatorCheckbox) {
            validatorCheckbox.disabled = disabled;
            validatorCheckbox.parentElement.style.color = disabled ? '#666' : '#c0c0c0';
            validatorCheckbox.parentElement.style.cursor = disabled ? 'not-allowed' : 'pointer';
        }
    };

    /**
     * Adauga text in log-ul live si deruleaza la final
     * @param {string} text - Textul de adaugat
     * @param {boolean} [clear=false] - Daca se sterge continutul inainte de a adauga
     */
    const appendLog = (text, clear = false) => {
        if (text === null || text === undefined) return;

        // Update full log content (unfiltered)
        if (clear) {
            fullLogContent = text;
        } else {
            fullLogContent += '\n' + text;
        }

        // Apply mode-specific filter and display
        logTextarea.value = filterLogByMode(fullLogContent);
        logTextarea.scrollTop = logTextarea.scrollHeight;
    };
    
    /**
     * Load VM screen from backend with safety retry.
     * Prevents wiping the screen if server momentarily returns empty data due to file locking.
     */
    const loadVMScreen = async (retryCount = 0) => {
        try {
            const response = await fetch('/get_vm_screen_log');
            const data = await response.json();
            if (data.status === 'success') {
                // SAFETY CHECK:
                // If server returns empty data, but we currently have content displayed,
                // and this isn't a deliberate reset (we assume resets are handled elsewhere or accepted eventually),
                // it might be a read error/race condition. Retry a few times before clearing.

                const incomingData = data.data || '';
                const currentData = vmTextarea.value;

                // If incoming is empty, but current is NOT empty, and we haven't retried enough
                if (incomingData.trim() === '' && currentData.trim().length > 0 && retryCount < 3) {
                    console.warn(`Empty VM log received while content exists. Possible race condition. Retrying (${retryCount + 1}/3)...`);
                    setTimeout(() => loadVMScreen(retryCount + 1), 500); // Retry after 500ms
                    return;
                }

                vmTextarea.value = incomingData;
                vmTextarea.scrollTop = vmTextarea.scrollHeight;
            }
        } catch (error) {
            console.error('Error loading VM screen:', error);
        }
    };

    /**
     * Adauga text (nefiltrat) la ecranul VM si deruleaza
     * @param {string} text - Textul de adaugat
     * @param {boolean} [clear=false] - Daca se sterge continutul inainte de a adauga
     */
    const appendVMScreen = (text, clear = false) => {
        if (text === null || text === undefined) return;

        if (clear) {
            vmTextarea.value = text;
        } else {
            vmTextarea.value += text;
        }
        vmTextarea.scrollTop = vmTextarea.scrollHeight;
    };

    // --- Log View Mode Switcher ---

    // Initialize mode buttons
    updateModeButtons();

    // Mode switcher button handlers
    modeActionsBtn.addEventListener('click', () => {
        logViewMode = 'actions';
        sessionStorage.setItem('logViewMode', 'actions');
        updateModeButtons();
        applyModeFilter();
    });

    modeCommandsBtn.addEventListener('click', () => {
        logViewMode = 'commands';
        sessionStorage.setItem('logViewMode', 'commands');
        updateModeButtons();
        applyModeFilter();
    });

    // --- Salvare/Incarcare Setari Sesiune ---

    // Incarca setarile salvate (mod executie, obiectiv)
    const savedExecMode = sessionStorage.getItem('executionMode');
    if (savedExecMode) {
        document.querySelector(`input[name="execution_mode"][value="${savedExecMode}"]`).checked = true;
    }
    const savedSummMode = sessionStorage.getItem('summarizationMode');
    if (savedSummMode) {
        document.querySelector(`input[name="summarization_mode"][value="${savedSummMode}"]`).checked = true;
    }
    const savedAllowAsk = sessionStorage.getItem('allowAsk');
    if (savedAllowAsk && allowAskCheckbox) {
        allowAskCheckbox.checked = (savedAllowAsk === 'true');
    }
    const savedTimeout = sessionStorage.getItem('commandTimeout');
    const commandTimeoutInput = document.getElementById('command-timeout-input');
    const updateTimeoutBtn = document.getElementById('update-timeout-btn');
    const timeoutCountdown = document.getElementById('timeout-countdown');
    if (savedTimeout && commandTimeoutInput) {
        commandTimeoutInput.value = savedTimeout;
    }
    const savedObjective = sessionStorage.getItem('savedObjective');
    if (savedObjective) {
        objectiveTextarea.value = savedObjective;
    }

    // Salveaza setarile la modificare
    objectiveTextarea.addEventListener('input', () => {
        sessionStorage.setItem('savedObjective', objectiveTextarea.value);
    });
    if (commandTimeoutInput) {
        commandTimeoutInput.addEventListener('change', () => {
            sessionStorage.setItem('commandTimeout', commandTimeoutInput.value);
        });
    }
    executionModeRadios.forEach(radio => {
        radio.addEventListener('change', (e) => {
            const newMode = e.target.value;
            sessionStorage.setItem('executionMode', newMode);
            // Daca task-ul e pe pauza, trimitem actualizarea la server
            if (pauseButton.style.display === 'block' && pauseButton.textContent === 'Resume') {
                 socket.emit('update_execution_mode', { mode: newMode });
            }
        });
    });
    summarizationModeRadios.forEach(radio => {
        radio.addEventListener('change', (e) => {
            sessionStorage.setItem('summarizationMode', e.target.value);
        });
    });
    if (allowAskCheckbox) {
        allowAskCheckbox.addEventListener('change', (e) => {
            sessionStorage.setItem('allowAsk', e.target.checked);
        });
    }
    if (validatorCheckbox) {
        validatorCheckbox.addEventListener('change', (e) => {
            socket.emit('toggle_validator', { enabled: e.target.checked });
        });
    }

    // --- Handler-e Butoane ---

    executeButton.onclick = () => {
        if (objectiveTextarea.value.trim() === "") {
            openModal('objective-empty');
            return;
        }
        const selectedExecMode = document.querySelector('input[name="execution_mode"]:checked').value;
        const selectedSummMode = document.querySelector('input[name="summarization_mode"]:checked').value;
        const allowAsk = allowAskCheckbox ? allowAskCheckbox.checked : false;
        const commandTimeout = parseInt(document.getElementById('command-timeout-input').value) || 120;

        socket.emit('execute_task', {
            data: objectiveTextarea.value,
            mode: selectedExecMode,
            summarization_mode: selectedSummMode,
            allow_ask: allowAsk,
            command_timeout: commandTimeout
        });
    };

    stopButton.onclick = () => {
        // 1. Immediate Visual Feedback
        stopButton.textContent = "Stopping...";
        stopButton.disabled = true;
        stopButton.style.backgroundColor = "#7f8c8d"; // Grey out
        stopButton.style.cursor = "wait";

        // 2. Send signal
        socket.emit('stop_task');

        // 3. Cleanup modals
        closeModal('approval');
        closeModal('rejection');
        closeModal('ask');
    };

    pauseButton.onclick = () => {
        if (pauseButton.textContent === 'Pause') {
            socket.emit('pause_task');
        } else {
            // Trimitem obiectivul curent in caz ca a fost modificat in pauza
            socket.emit('resume_task', { data: objectiveTextarea.value });
        }
    };

    // Handler pentru Update Timeout
    if (updateTimeoutBtn) {
        updateTimeoutBtn.onclick = () => {
            const newTimeout = parseInt(commandTimeoutInput.value) || 120;
            sessionStorage.setItem('commandTimeout', newTimeout);
            socket.emit('update_timeout', { timeout: newTimeout });
            updateTimeoutBtn.textContent = '✓';
            updateTimeoutBtn.style.backgroundColor = '#27ae60';
            setTimeout(() => {
                updateTimeoutBtn.textContent = 'Update';
                updateTimeoutBtn.style.backgroundColor = '#4CAF50';
            }, 1500);
        };
    }

    // --- Handler-e SocketIO ---

    socket.on('agent_log', msg => {
        // Folosim noua functie de filtrare si formatare
        appendLog(msg.data, msg.clear === true);
    });

    socket.on('vm_screen', msg => {
        // Folosim functia de append pentru VM
        appendVMScreen(msg.data, msg.clear === true);
    });

    socket.on('task_started', () => {
        executeButton.style.display = 'none';
        stopButton.style.display = 'block';
        pauseButton.style.display = 'block';
        pauseButton.textContent = 'Pause';
        pauseButton.style.backgroundColor = '#e67e22'; // Culoare portocalie
        objectiveTextarea.disabled = true;
        setControlsDisabled(true);

        // Keep existing logs visible - context persists across tasks
    });

    socket.on('task_finished', () => {
        executeButton.style.display = 'block';
        stopButton.style.display = 'none';
        pauseButton.style.display = 'none';

        // FIX: Reset Stop Button State
        stopButton.textContent = "Stop Task";
        stopButton.disabled = false;
        stopButton.style.backgroundColor = "#c0392b"; // Restore red color
        stopButton.style.cursor = "pointer";

        objectiveTextarea.disabled = false;
        setControlsDisabled(false);
        closeModal('approval');
        closeModal('rejection');
        closeModal('ask');

        // --- Restore Chat View (Persistent Logic) ---
        const isTaskFromChat = sessionStorage.getItem('isTaskFromChat') === 'true';
        // We only trigger this if we are LIVE on the page when it finishes.
        // If we just loaded the page and handled it via initial_state, pendingChatAnalysis would have cleared isTaskFromChat already.

        if (isTaskFromChat) {
            console.log("Restoring Chat View (Task finished live)...");
            const wasChatFullscreen = sessionStorage.getItem('wasChatFullscreen') === 'true';

            switchTab('chat');

            if (wasChatFullscreen && !isChatFullscreen) {
                toggleFullscreen();
            }

            socket.emit('analyze_task_result');

            sessionStorage.removeItem('isTaskFromChat');
            sessionStorage.removeItem('wasChatFullscreen');
            // Ensure pending flag is cleared just in case
            sessionStorage.removeItem('pendingChatAnalysis');
        }
    });

    socket.on('task_paused', () => {
        pauseButton.textContent = 'Resume';
        pauseButton.style.backgroundColor = '#2ecc71'; // Culoare verde
        objectiveTextarea.disabled = false; // Permitem editarea obiectivului in pauza
        setControlsDisabled(false); // Permitem schimbarea modului in pauza
    });

    socket.on('task_resumed', () => {
        pauseButton.textContent = 'Pause';
        pauseButton.style.backgroundColor = '#e67e22'; // Culoare portocalie
        objectiveTextarea.disabled = true;
        setControlsDisabled(true);
    });
    
    socket.on('awaiting_user_answer', () => {
        // Cand agentul intreaba, deblocam campul obiectivului
        if (objectiveTextarea) {
            objectiveTextarea.disabled = false;
        }
    });

    socket.on('timeout_updated', (data) => {
        if (commandTimeoutInput) {
            commandTimeoutInput.value = data.timeout;
            sessionStorage.setItem('commandTimeout', data.timeout);
        }
        appendLog(`--- Timeout updated to ${data.timeout} seconds ---`);
    });

    // --- Status Bar Logic (Thinking & Execution) ---
    const executionStatusDiv = document.getElementById('execution-status');

    function updateExecutionStatus(text) {
        if (executionStatusDiv) {
            executionStatusDiv.textContent = text;
        }
    }

    // --- Thinking Indicator Handlers ---
    socket.on('thinking_start', (data) => {
        updateExecutionStatus(`Thinking... (${data.timeout}s timeout)`);
    });

    socket.on('thinking_update', (data) => {
        updateExecutionStatus(`Thinking... (${data.remaining}s remaining)`);
    });

    socket.on('thinking_end', () => {
        updateExecutionStatus('');
    });

    // --- Command Execution Timer Handlers ---
    socket.on('command_exec_start', (data) => {
        // Keep updating the header countdown if present
        if (timeoutCountdown) {
             timeoutCountdown.textContent = `(${data.timeout}s)`;
        }
        updateExecutionStatus(`Executing command... (${data.timeout}s timeout)`);
    });

    socket.on('command_exec_update', (data) => {
        if (timeoutCountdown) {
             timeoutCountdown.textContent = `(${data.remaining}s remaining)`;
        }
        updateExecutionStatus(`Executing command... (${data.remaining}s remaining)`);
    });

    socket.on('command_exec_end', () => {
        if (timeoutCountdown) {
             timeoutCountdown.textContent = '';
        }
        updateExecutionStatus('');
    });

    // Handler-ul central pentru starea initiala (la conectare/reconectare)
    socket.on('initial_state', (data) => {
        if(data.last_log) {
            // Folosim functia de logare cu 'clear=true'
            // Aceasta va filtra, formata (cu timestamp-uri) si afisa log-ul la incarcare
            appendLog(data.last_log, true);
        }
        if(data.vm_output) {
            // Folosim functia VM cu 'clear=true'
            appendVMScreen(data.vm_output, true);
        }

        // Sync Validator Checkbox
        if (validatorCheckbox && data.validator_enabled !== undefined) {
            validatorCheckbox.checked = data.validator_enabled;
        }

        const isPaused = data.task_running && data.task_paused;
        const isRunning = data.task_running && !data.task_paused;

        if (data.task_running) {
            executeButton.style.display = 'none';
            stopButton.style.display = 'block';
            pauseButton.style.display = 'block';
            objectiveTextarea.disabled = isRunning; // true daca ruleaza, false daca e pe pauza
            setControlsDisabled(isRunning);

            if (isPaused) {
                pauseButton.textContent = 'Resume';
                pauseButton.style.backgroundColor = '#2ecc71'; // Verde
            } else {
                pauseButton.textContent = 'Pause';
                pauseButton.style.backgroundColor = '#e67e22'; // Portocaliu
            }
        } else {
            executeButton.style.display = 'block';
            stopButton.style.display = 'none';
            pauseButton.style.display = 'none';
            objectiveTextarea.disabled = false;
            setControlsDisabled(false);

            // --- NEW: Check for Pending Chat Analysis (from page navigation) ---
            const pendingAnalysis = sessionStorage.getItem('pendingChatAnalysis') === 'true';

            if (pendingAnalysis) {
                console.log("Found pending chat analysis from previous session/page.");

                // 1. Restore Chat View
                switchTab('chat');

                // 2. Restore Fullscreen if needed
                const wasChatFullscreen = sessionStorage.getItem('wasChatFullscreen') === 'true';
                if (wasChatFullscreen && !isChatFullscreen) {
                    toggleFullscreen();
                }

                // 3. Trigger Analysis (The task is already done)
                socket.emit('analyze_task_result');

                // 4. Clear Flags
                sessionStorage.removeItem('pendingChatAnalysis');
                sessionStorage.removeItem('isTaskFromChat');
                sessionStorage.removeItem('wasChatFullscreen');
            }
        }
    });

    // Listen for history updates to reload VM screen
    socket.on('update_history', () => {
        // Reload VM screen when history updates
        loadVMScreen();
    });

    // --- CHAT & TABS LOGIC ---
    const tabExecution = document.getElementById('tab-execution');
    const tabChat = document.getElementById('tab-chat');
    const viewExecution = document.getElementById('view-execution');
    const viewChat = document.getElementById('view-chat');

    const chatInput = document.getElementById('chat-input');
    const sendChatBtn = document.getElementById('send-chat-btn');
    const chatHistory = document.getElementById('chat-history');
    const chatHistoryContainer = document.getElementById('chat-history-container');
    const chatTypingIndicator = document.getElementById('chat-typing-indicator');
    const clearChatBtn = document.getElementById('clear-chat-btn');
    const chatFullscreenBtn = document.getElementById('chat-fullscreen-btn');
    const mainLeftColumn = document.getElementById('main-left-column');

    const taskProposalArea = document.getElementById('task-proposal-area');
    const proposalText = document.getElementById('proposal-text');
    const acceptProposalBtn = document.getElementById('accept-proposal-btn');
    const rejectProposalBtn = document.getElementById('reject-proposal-btn');

    let isChatFullscreen = false;
    // Note: isTaskFromChat and wasChatFullscreen now use sessionStorage for persistence

    // --- Helper: Toggle Log Section Visibility ---
    function toggleLogVisibility(shouldShow) {
        const logTextarea = document.getElementById('log-textarea');
        if (!logTextarea) return;

        // Find parent .section container
        const logSection = logTextarea.closest('.section');
        if (logSection) {
            logSection.style.display = shouldShow ? 'flex' : 'none';
        }
    }

    // --- 1. Tab Switching ---
    window.switchTab = function(tab) {
        // Update Buttons
        document.getElementById('tab-execution').style.borderBottom = tab === 'execution' ? '2px solid #4CAF50' : 'none';
        document.getElementById('tab-execution').style.color = tab === 'execution' ? 'white' : '#aaa';

        document.getElementById('tab-chat').style.borderBottom = tab === 'chat' ? '2px solid #4CAF50' : 'none';
        document.getElementById('tab-chat').style.color = tab === 'chat' ? 'white' : '#aaa';

        // Update Views
        document.getElementById('view-execution').style.display = tab === 'execution' ? 'flex' : 'none';
        document.getElementById('view-chat').style.display = tab === 'chat' ? 'flex' : 'none';

        // Toggle Log Visibility (Hide in Chat, Show in Execution)
        if (tab === 'chat') {
            toggleLogVisibility(false); // Hide log to maximize chat space
        } else {
            toggleLogVisibility(true); // Show log for execution monitoring
        }

        // --- FIX: Auto-scroll to bottom when switching to Chat ---
        if (tab === 'chat') {
            setTimeout(() => {
                const container = document.getElementById('chat-history-container');
                if (container) {
                    container.scrollTop = container.scrollHeight;
                }
            }, 100); // Small delay to ensure DOM is rendered
        }
    };
    tabExecution.onclick = () => switchTab('execution');
    tabChat.onclick = () => switchTab('chat');

    // --- CHAT RESIZER LOGIC ---
    const resizerHandle = document.getElementById('chat-resizer-handle');
    const inputContainer = document.getElementById('chat-input-container');

    // Variables to track drag state
    let isResizing = false;
    let startY = 0;
    let startHeight = 0;

    if (resizerHandle && inputContainer) {
        resizerHandle.addEventListener('mousedown', (e) => {
            isResizing = true;
            startY = e.clientY;
            startHeight = parseInt(window.getComputedStyle(inputContainer).height, 10);

            // Visual feedback
            resizerHandle.classList.add('dragging');
            document.body.style.cursor = 'row-resize';

            // Prevent text selection while dragging
            e.preventDefault();
        });

        document.addEventListener('mousemove', (e) => {
            if (!isResizing) return;

            // Calculate delta (Movement UP means delta is negative, so we add to height)
            // If we move Mouse UP (lower Y), the Input Height should INCREASE.
            const delta = startY - e.clientY;
            const newHeight = startHeight + delta;

            // Apply new height (CSS min/max-height will constrain it automatically)
            inputContainer.style.height = `${newHeight}px`;
        });

        document.addEventListener('mouseup', () => {
            if (isResizing) {
                isResizing = false;
                resizerHandle.classList.remove('dragging');
                document.body.style.cursor = 'default';
            }
        });
    }

    // --- 2. Fullscreen Logic ---
    function toggleFullscreen() {
        isChatFullscreen = !isChatFullscreen;
        const icon = chatFullscreenBtn.querySelector('i');

        if (isChatFullscreen) {
            mainLeftColumn.classList.add('fullscreen-chat-mode');

            // Update icon and text
            if (icon) {
                icon.className = 'fa-solid fa-compress';
            }
            chatFullscreenBtn.innerHTML = '<i class="fa-solid fa-compress"></i> Exit';
            chatFullscreenBtn.style.borderColor = "#f39c12";
        } else {
            mainLeftColumn.classList.remove('fullscreen-chat-mode');

            // Update icon and text
            if (icon) {
                icon.className = 'fa-solid fa-expand';
            }
            chatFullscreenBtn.innerHTML = '<i class="fa-solid fa-expand"></i> Fullscreen';
            chatFullscreenBtn.style.borderColor = "#444";
        }
    }
    chatFullscreenBtn.onclick = toggleFullscreen;

    // --- 3. Chat Messages ---
    function addChatMessage(role, text) {
        // --- FIX: Hide Internal System Prompts from UI ---
        // These messages are for the LLM only (Prompt Injection) and shouldn't be seen by the user.
        if (text.includes('[ACTION COMPLETED]') && text.includes('INSTRUCTION:')) {
            console.log("Hidden system message:", text.substring(0, 50) + "...");
            return;
        }
        // ------------------------------------------------

        // Remove greeting if present
        const greeting = document.getElementById('chat-greeting');
        if (greeting) greeting.remove();

        const div = document.createElement('div');
        // Apply the new CSS classes
        div.className = `chat-bubble ${role === 'user' ? 'user' : 'agent'}`;

        if (role === 'user') {
            div.innerHTML = `<strong>You:</strong> ${text.replace(/\n/g, '<br>')}`;
        } else {
            div.innerHTML = `<strong>Agent:</strong> ${text.replace(/\n/g, '<br>')}`;
        }

        chatHistory.appendChild(div);

        // Auto-scroll to bottom of the scrollable container
        setTimeout(() => {
            chatHistoryContainer.scrollTop = chatHistoryContainer.scrollHeight;
        }, 50);
    }

    // --- Updated Input Logic (Textarea) ---

    chatInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault(); // Prevent new line
            sendChatBtn.click();
        }
    });

    sendChatBtn.onclick = () => {
        const msg = chatInput.value.trim();
        if (!msg) return;

        addChatMessage('user', msg);
        chatInput.value = '';
        // Optional: Reset height if you implemented auto-grow

        socket.emit('send_chat_message', { message: msg });
    };

    socket.on('chat_response', (data) => addChatMessage(data.role, data.content));

    socket.on('chat_status', (data) => {
        // Show/hide typing indicator in header
        if (chatTypingIndicator) {
            chatTypingIndicator.style.display = (data.status === 'thinking') ? 'inline' : 'none';
        }
    });

    // --- 4. Persistent History Restoration ---
    socket.on('initial_state', (data) => {
        // ... existing initialization handled elsewhere ...

        // Restore Chat
        if (data.chat_history && Array.isArray(data.chat_history)) {
            chatHistory.innerHTML = ''; // Clear
            if (data.chat_history.length === 0) {
                 chatHistory.innerHTML = '<div id="chat-greeting" style="color: #666; text-align: center; margin-top: 20px;"><p>Chat with the agent about executed tasks.</p></div>';
            } else {
                data.chat_history.forEach(msg => addChatMessage(msg.role, msg.content));
            }
        }
    });

    // --- 5. Clear Chat ---
    clearChatBtn.onclick = () => {
        if(confirm("Are you sure you want to clear the chat history?")) {
            socket.emit('clear_chat');
        }
    };

    socket.on('chat_history_cleared', () => {
        chatHistory.innerHTML = '<div id="chat-greeting" style="color: #666; text-align: center; margin-top: 20px;"><p>Chat with the agent about executed tasks.</p></div>';
    });

    // --- 6. Action Plan Status & Modal ---
    const actionPlanBtn = document.getElementById('action-plan-status-btn');
    const actionPlanText = document.getElementById('action-plan-status-text');
    const actionPlanModal = document.getElementById('action-plan-modal');
    const actionPlanOverlay = document.getElementById('action-plan-modal-overlay');
    const actionPlanContent = document.getElementById('action-plan-content');

    // Edit mode state
    let isPlanEditMode = false;
    let currentPlanData = null;

    // Function to update action plan status text
    function updateActionPlanButton(planData) {
        if (!planData || !planData.exists) {
            actionPlanText.textContent = 'No active plan';
            actionPlanText.style.color = '#888';
            return;
        }

        // Update text with current progress
        if (planData.next_step_index) {
            actionPlanText.textContent = `Step ${planData.next_step_index}/${planData.total_steps} in progress...`;
            actionPlanText.style.color = '#f39c12';
        } else {
            actionPlanText.textContent = `All ${planData.total_steps} steps completed ✓`;
            actionPlanText.style.color = '#4CAF50';
        }
    }

    // Make action plan button clickable to open modal
    if (actionPlanBtn) {
        actionPlanBtn.addEventListener('click', () => {
            // Fetch current plan and open modal
            fetch('/get_action_plan')
                .then(res => res.json())
                .then(data => {
                    displayActionPlan(data);
                    // Show modal using the standard openModal function
                    openModal('action-plan');
                })
                .catch(err => {
                    console.error('Error fetching action plan:', err);
                });
        });
    }

    // Function to format and display action plan in modal
    function displayActionPlan(planData) {
        currentPlanData = planData;

        if (!planData || !planData.exists) {
            // Show create new plan option
            actionPlanContent.innerHTML = `
                <div style="text-align: center; padding: 40px;">
                    <p style="color: #999; font-size: 1.2em; margin-bottom: 20px;">
                        No active action plan exists.
                    </p>
                    <button onclick="createNewPlan()"
                            style="background-color: #27ae60; color: white; padding: 12px 24px; border: none; border-radius: 6px; cursor: pointer; font-size: 1em; font-weight: bold;">
                        + Create New Plan
                    </button>
                </div>
            `;
            document.getElementById('clear-plan-btn').style.display = 'none';
            document.getElementById('btn-edit-plan').style.display = 'none';
            document.getElementById('btn-add-step').style.display = 'none';
            document.getElementById('btn-save-plan').style.display = 'none';
            return;
        }

        // Show appropriate buttons based on edit mode
        if (isPlanEditMode) {
            renderPlanEditMode(planData);
        } else {
            renderPlanViewMode(planData);
        }
    }

    // Render plan in view mode (read-only)
    function renderPlanViewMode(planData) {
        document.getElementById('clear-plan-btn').style.display = 'block';
        document.getElementById('btn-edit-plan').style.display = 'block';
        document.getElementById('btn-add-step').style.display = 'none';
        document.getElementById('btn-save-plan').style.display = 'none';

        let html = `<div style="margin-bottom: 15px;">
                        <strong style="color: #7aa5d2; font-size: 16px;">${planData.title}</strong>
                        <div style="color: #888; font-size: 11px; margin-top: 5px;">
                            Progress: ${planData.completed_steps}/${planData.total_steps} completed
                        </div>
                    </div>
                    <div style="margin-top: 15px;">`;

        planData.steps.forEach((step, idx) => {
            const stepNum = idx + 1;
            const isCompleted = step.completed;
            const isCurrent = stepNum === planData.next_step_index;

            const checkbox = isCompleted ? '☑' : '☐';
            const textColor = isCompleted ? '#81c784' : (isCurrent ? '#f39c12' : '#c0c0c0');
            const fontWeight = isCurrent ? 'bold' : 'normal';

            html += `<div style="margin-bottom: 10px; padding: 8px; background-color: ${isCurrent ? '#2d2d30' : 'transparent'}; border-left: 3px solid ${isCurrent ? '#f39c12' : 'transparent'}; border-radius: 2px;">
                        <span style="color: ${textColor}; font-weight: ${fontWeight};">
                            ${checkbox} Step ${stepNum}. ${step.objective}
                        </span>
                     </div>`;
        });

        if (planData.next_step_index) {
            html += `</div><div style="margin-top: 15px; padding: 10px; background-color: #2d2d30; border: 1px solid #f39c12; border-radius: 4px; color: #f39c12; font-size: 12px;">
                        <strong>Next:</strong> Step ${planData.next_step_index} - Use "Request Task" in chat to initiate.
                     </div>`;
        } else {
            html += `</div><div style="margin-top: 15px; padding: 10px; background-color: #2d2d30; border: 1px solid #4CAF50; border-radius: 4px; color: #4CAF50; font-size: 12px;">
                        All steps completed! Plan finished.
                     </div>`;
        }

        actionPlanContent.innerHTML = html;
    }

    // Render plan in edit mode
    function renderPlanEditMode(planData) {
        document.getElementById('clear-plan-btn').style.display = 'none';
        document.getElementById('btn-edit-plan').textContent = 'Cancel';
        document.getElementById('btn-edit-plan').style.backgroundColor = '#95a5a6';
        document.getElementById('btn-add-step').style.display = 'block';
        document.getElementById('btn-save-plan').style.display = 'block';

        let html = `<div style="margin-bottom: 15px;">
                        <label style="color: #888; font-size: 12px; display: block; margin-bottom: 5px;">Plan Title:</label>
                        <input type="text" id="edit-plan-title" value="${planData.title}"
                               style="width: 100%; padding: 8px; background: #2d2d30; color: white; border: 1px solid #555; border-radius: 4px; font-family: monospace; box-sizing: border-box;">
                    </div>
                    <div id="edit-steps-container" style="margin-top: 15px;">`;

        planData.steps.forEach((step, idx) => {
            const isCompleted = step.completed;
            const bgColor = isCompleted ? '#222' : '#2d2d30';
            const textColor = isCompleted ? '#888' : '#fff';
            const disabled = isCompleted ? 'readonly' : '';
            const deleteDisabled = isCompleted ? 'disabled' : '';
            const deleteBg = isCompleted ? '#444' : '#c0392b';
            const deleteCursor = isCompleted ? 'not-allowed' : 'pointer';

            html += `<div class="edit-step-item" style="display: flex; align-items: center; margin-bottom: 10px; gap: 8px;">
                        <input type="checkbox" class="edit-step-check" ${isCompleted ? 'checked' : ''} style="margin: 0; flex-shrink: 0; width: 16px; height: 16px;">
                        <input type="text" class="edit-step-text" value="${step.objective}" ${disabled}
                               style="flex: 1; min-width: 0; padding: 8px; background: ${bgColor}; color: ${textColor}; border: 1px solid #555; border-radius: 4px; font-family: monospace; box-sizing: border-box;">
                        <button onclick="this.parentElement.remove()" ${deleteDisabled}
                                style="background: ${deleteBg}; color: white; border: none; padding: 8px 12px; border-radius: 4px; cursor: ${deleteCursor}; flex-shrink: 0; width: 70px; min-width: 70px; max-width: 70px;">
                            Delete
                        </button>
                     </div>`;
        });

        html += `</div>`;
        actionPlanContent.innerHTML = html;
    }

    // Request action plan data from server
    function requestActionPlan() {
        socket.emit('get_action_plan');
    }

    // Listen for action plan data from server
    socket.on('action_plan_data', (data) => {
        // Don't update if user is currently editing/creating a plan
        if (isPlanEditMode) {
            console.log('Skipping plan update - user is in edit mode');
            return;
        }

        updateActionPlanButton(data);
        displayActionPlan(data);
    });

    // Listen for action plan cleared event
    socket.on('action_plan_cleared', () => {
        actionPlanBtn.textContent = 'Action Plan (None)';
        actionPlanBtn.style.borderColor = '#666';
        actionPlanBtn.style.color = '#666';
        actionPlanContent.innerHTML = '<p style="color: #666; text-align: center;">No active action plan</p>';
        document.getElementById('clear-plan-btn').style.display = 'none';
        isPlanEditMode = false;
        currentPlanData = null;
    });

    // Open modal when button clicked
    actionPlanBtn.onclick = () => {
        requestActionPlan();
        showModal('action-plan');
    };

    // Create new plan from zero
    window.createNewPlan = () => {
        isPlanEditMode = true;
        currentPlanData = {
            exists: true,
            title: 'New Action Plan',
            steps: [{ objective: 'Step 1', completed: false }],
            total_steps: 1,
            completed_steps: 0
        };
        displayActionPlan(currentPlanData);
    };

    // Toggle edit mode
    window.togglePlanEditMode = () => {
        if (!currentPlanData || !currentPlanData.exists) return;

        isPlanEditMode = !isPlanEditMode;

        if (!isPlanEditMode) {
            // Exiting edit mode - restore original button state
            document.getElementById('btn-edit-plan').textContent = 'Edit Plan';
            document.getElementById('btn-edit-plan').style.backgroundColor = '#3498db';
            // Refresh to show view mode
            requestActionPlan();
        } else {
            // Entering edit mode
            displayActionPlan(currentPlanData);
        }
    };

    // Add a new step in edit mode
    window.addEditStep = () => {
        const container = document.getElementById('edit-steps-container');
        if (!container) return;

        const newStepHtml = `<div class="edit-step-item" style="display: flex; align-items: center; margin-bottom: 10px; gap: 8px;">
                                <input type="checkbox" class="edit-step-check" style="margin: 0; flex-shrink: 0; width: 16px; height: 16px;">
                                <input type="text" class="edit-step-text" value="" placeholder="Enter step objective..."
                                       style="flex: 1; min-width: 0; padding: 8px; background: #2d2d30; color: #fff; border: 1px solid #555; border-radius: 4px; font-family: monospace; box-sizing: border-box;">
                                <button onclick="this.parentElement.remove()"
                                        style="background: #c0392b; color: white; border: none; padding: 8px 12px; border-radius: 4px; cursor: pointer; flex-shrink: 0; width: 70px; min-width: 70px; max-width: 70px;">
                                    Delete
                                </button>
                             </div>`;

        container.insertAdjacentHTML('beforeend', newStepHtml);
    };

    // Toggle fullscreen mode for action plan modal
    let isPlanFullscreen = false;
    window.togglePlanFullscreen = () => {
        const modal = document.getElementById('action-plan-modal');
        const overlay = document.getElementById('action-plan-modal-overlay');
        const content = document.getElementById('action-plan-content');
        const btn = document.getElementById('btn-fullscreen-plan');

        if (!modal || !overlay || !content) return;

        isPlanFullscreen = !isPlanFullscreen;

        if (isPlanFullscreen) {
            // Enter fullscreen - CRITICAL: Reset transform to prevent off-screen positioning
            modal.style.position = 'fixed';
            modal.style.top = '0';
            modal.style.left = '0';
            modal.style.right = '0';
            modal.style.bottom = '0';
            modal.style.width = '100vw';
            modal.style.height = '100vh';
            modal.style.maxWidth = '100vw';
            modal.style.margin = '0';
            modal.style.borderRadius = '0';
            modal.style.transform = 'none'; // CRITICAL: Override the default translate(-50%, -50%)
            modal.style.overflowX = 'hidden'; // Prevent horizontal scroll
            modal.style.boxSizing = 'border-box'; // Include padding in width calculation
            modal.style.zIndex = '10001';

            // Make content area take up more space
            content.style.height = 'calc(100vh - 200px)';
            content.style.maxHeight = 'calc(100vh - 200px)';

            // Update overlay to be behind the fullscreen modal
            overlay.style.zIndex = '10000';

            // Update button icon
            btn.textContent = '🗗';
            btn.title = 'Exit Fullscreen';
        } else {
            // Exit fullscreen - restore all default values
            modal.style.position = '';
            modal.style.top = '';
            modal.style.left = '';
            modal.style.right = '';
            modal.style.bottom = '';
            modal.style.width = '';
            modal.style.height = '';
            modal.style.maxWidth = '';
            modal.style.margin = '';
            modal.style.borderRadius = '';
            modal.style.transform = ''; // Restore default transform
            modal.style.overflowX = ''; // Restore default overflow (will use inline style from layout.html)
            modal.style.boxSizing = ''; // Restore default box-sizing (will use inline style from layout.html)
            modal.style.zIndex = '';

            // Reset content area
            content.style.height = '';
            content.style.maxHeight = '';

            // Reset overlay
            overlay.style.zIndex = '';

            // Update button icon
            btn.textContent = '⛶';
            btn.title = 'Toggle Fullscreen';
        }
    };

    // Save plan changes
    window.savePlanChanges = () => {
        const titleInput = document.getElementById('edit-plan-title');
        const title = titleInput ? titleInput.value.trim() : currentPlanData?.title || 'Action Plan';

        if (!title) {
            alert('Plan title cannot be empty!');
            return;
        }

        const stepElements = document.querySelectorAll('.edit-step-item');
        const steps = [];

        stepElements.forEach(el => {
            const textInput = el.querySelector('.edit-step-text');
            const checkInput = el.querySelector('.edit-step-check');
            if (textInput && textInput.value.trim() !== '') {
                steps.push({
                    objective: textInput.value.trim(),
                    completed: checkInput ? checkInput.checked : false
                });
            }
        });

        if (steps.length === 0) {
            alert('Plan must have at least one step!');
            return;
        }

        // Send update to server
        fetch('/update_action_plan', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ title: title, steps: steps })
        })
        .then(response => response.json())
        .then(data => {
            if (data.status === 'success') {
                isPlanEditMode = false;
                alert('Plan saved successfully!');
                requestActionPlan();
            } else {
                alert('Error saving plan: ' + (data.message || 'Unknown error'));
            }
        })
        .catch(error => {
            console.error('Error saving plan:', error);
            alert('Network error while saving plan');
        });
    };

    // Clear plan function (called from modal button)
    window.clearActionPlan = () => {
        if (confirm('Are you sure you want to clear the current action plan?')) {
            socket.emit('clear_action_plan');
        }
    };

    // Auto-refresh action plan status every 3 seconds when chat tab is active
    setInterval(() => {
        const chatView = document.getElementById('view-chat');
        // Don't refresh if user is editing/creating a plan
        if (chatView && chatView.style.display !== 'none' && !isPlanEditMode) {
            requestActionPlan();
        }
    }, 3000);

    // Initial load
    requestActionPlan();

    // --- 7. Task Proposal & Transition Logic ---

    // NEW: Handle Auto-Accept Checkbox State
    const autoAcceptCheckbox = document.getElementById('auto-accept-tasks-checkbox');

    // Load saved state
    if (sessionStorage.getItem('autoAcceptTasks') === 'true') {
        autoAcceptCheckbox.checked = true;
    }

    // Save state on change
    autoAcceptCheckbox.addEventListener('change', (e) => {
        sessionStorage.setItem('autoAcceptTasks', e.target.checked);
    });

    socket.on('chat_task_proposal', (data) => {
        // Define the acceptance logic as a reusable function
        const executeProposal = () => {
             // 1. Save State to Session Storage (Persistent)
            sessionStorage.setItem('isTaskFromChat', 'true');
            sessionStorage.setItem('wasChatFullscreen', isChatFullscreen ? 'true' : 'false');

            // 2. Exit Fullscreen if active (to show execution)
            if (isChatFullscreen) {
                toggleFullscreen();
            }

            // 3. Switch to execution tab
            switchTab('execution');

            // 4. Set objective
            const objectiveTextarea = document.getElementById('objective-textarea');
            if (objectiveTextarea) {
                objectiveTextarea.value = data.objective;
                objectiveTextarea.dispatchEvent(new Event('input'));
            }

            // 5. AUTO EXECUTE
            const executeButton = document.getElementById('execute-button');
            if (executeButton) {
                console.log("Auto-executing task from chat...");
                executeButton.click();
            }
        };

        // CHECK AUTO-ACCEPT STATUS
        if (autoAcceptCheckbox.checked) {
            // Auto-accept logic
            addChatMessage('assistant', `[Auto-Accepting Task: "${data.objective}"]`);
            executeProposal();
        } else {
            // Manual logic (Show UI)
            taskProposalArea.style.display = 'block';
            proposalText.textContent = data.objective;

            acceptProposalBtn.onclick = () => {
                executeProposal();
                // Hide proposal UI
                taskProposalArea.style.display = 'none';
                addChatMessage('assistant', `[Task "${data.objective}" initiated.]`);
            };

            rejectProposalBtn.onclick = () => {
                taskProposalArea.style.display = 'none';
                addChatMessage('user', '[Task proposal declined]');
            };
        }
    });

    // --- Fullscreen Logic (Chat, Log, Screen) ---
    const fullscreenStyle = document.createElement('style');
    fullscreenStyle.innerHTML = `
        /* --- CHAT FULLSCREEN --- */
        .fullscreen-chat-mode {
            position: fixed !important; top: 0; left: 0; right: 0; bottom: 0;
            z-index: 9999; background-color: #121212; padding: 20px;
            display: flex !important; flex-direction: column;
            width: 100% !important; height: 100% !important;
            box-sizing: border-box;
        }
        .fullscreen-chat-mode > * { display: none !important; }
        .fullscreen-chat-mode #view-chat {
            display: flex !important; flex-grow: 1; width: 100%; height: 100%; max-width: 100%;
        }

        /* --- LOG FULLSCREEN --- */
        .fullscreen-log-mode { overflow: hidden; }
        .fullscreen-log-mode #log-section-container {
            position: fixed !important; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 9999; background-color: #121212; padding: 20px; box-sizing: border-box;
            display: flex; flex-direction: column;
        }
        .fullscreen-log-mode #log-textarea { flex-grow: 1; height: 100% !important; }

        /* --- SCREEN FULLSCREEN (FIXED) --- */
        .fullscreen-screen-mode { overflow: hidden; }
        .fullscreen-screen-mode #main-right-column {
            position: fixed !important; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 9999; background-color: #121212; padding: 10px; box-sizing: border-box;
            display: flex !important; flex-direction: column;
        }
        /* Ensure the section inside the column fills the height */
        .fullscreen-screen-mode #main-right-column .section {
            flex-grow: 1; display: flex; flex-direction: column; height: 100%;
        }
        /* Target the correct textarea ID */
        .fullscreen-screen-mode #vm-textarea {
            flex-grow: 1; height: 100% !important;
        }
    `;
    document.head.appendChild(fullscreenStyle);

    // Identify container for the log to maximize
    const logSection = document.getElementById('log-textarea').closest('.section');
    if(logSection) logSection.id = 'log-section-container';

    // --- Event Listeners ---

    // 1. Log Fullscreen
    const logBtn = document.getElementById('log-fullscreen-btn');
    if(logBtn) {
        logBtn.addEventListener('click', () => {
            document.body.classList.toggle('fullscreen-log-mode');
        });
    }

    // 2. Screen Fullscreen
    const screenBtn = document.getElementById('screen-fullscreen-btn');
    if(screenBtn) {
        screenBtn.addEventListener('click', () => {
            document.body.classList.toggle('fullscreen-screen-mode');
            // Trigger resize event for xterm.js if needed
            window.dispatchEvent(new Event('resize'));
        });
    }

    // Initialize views on page load
    loadVMScreen();

    // ========================================
    // HISTORY OVERLAY FUNCTIONALITY
    // ========================================

    const historyOverlay = document.getElementById('history-overlay');
    const closeHistoryOverlayBtn = document.getElementById('close-history-overlay');

    // Global function to open history overlay (called from navbar)
    window.openHistoryOverlay = function() {
        if (historyOverlay) {
            historyOverlay.style.display = 'block';
            // Load agent memory when opening
            loadAgentMemory();
        }
    };

    // Close overlay handler
    if (closeHistoryOverlayBtn) {
        closeHistoryOverlayBtn.addEventListener('click', () => {
            if (historyOverlay) {
                historyOverlay.style.display = 'none';
            }
        });
    }

    // === History Page JavaScript (from history.html) ===
    const resetButton = document.getElementById('reset-button');
    const debugButton = document.getElementById('debug-button');
    const historyTextarea = document.getElementById('history-textarea');
    const rawLlmTextarea = document.getElementById('raw-llm-textarea');

    // Elemente Noi pentru Editare
    const editHistoryButton = document.getElementById('edit-history-button');
    const editHistoryTextarea = document.getElementById('edit-history-textarea');
    const saveHistoryButton = document.getElementById('save-history-button');
    const editHistoryCloseBtn = document.querySelector('.modal-close-btn[data-modal-id="edit-history"]');
    const editHistoryOverlay = document.getElementById('edit-history-modal-overlay');

    // New search elements
    const searchInput = document.getElementById('search-input');
    const searchBtn = document.getElementById('search-btn');
    const refreshHistoryBtn = document.getElementById('refresh-history-btn');
    const searchResults = document.getElementById('search-results');
    const searchResultsContent = document.getElementById('search-results-content');
    const searchLoading = document.getElementById('search-loading');
    const searchResultsContainer = document.getElementById('search-results-container');
    const addToContextBtn = document.getElementById('add-to-context-btn');
    const closeSearchResultsBtn = document.getElementById('close-search-results-btn');
    const executionPausedWarning = document.getElementById('execution-paused-warning');

    // View switcher buttons
    const viewLlmContextBtn = document.getElementById('view-llm-context-btn');
    const viewFullLogBtn = document.getElementById('view-full-log-btn');

    // Track current view mode and search results
    let currentView = sessionStorage.getItem('historyViewMode') || 'llm_context';
    let lastSearchResults = '';
    let lastSearchReason = '';
    let isTaskRunning = false;

    if (resetButton) {
        resetButton.onclick = () => {
            openModal('reset-confirm');
        };
    }

    if (debugButton) {
        debugButton.onclick = () => {
            openModal('raw-llm');
        };
    }

    if (editHistoryButton) {
        editHistoryButton.onclick = () => {
            // Auto-Pause: If task is running, request a pause immediately
            if (isTaskRunning) {
                console.log("Auto-pausing task for memory editing...");
                socket.emit('pause_task');
            }

            editHistoryTextarea.value = historyTextarea.value;
            editHistoryTextarea.scrollTop = 0;
            openModal('edit-history');
        };
    }

    if (saveHistoryButton) {
        saveHistoryButton.onclick = () => {
            const newHistory = editHistoryTextarea.value;
            socket.emit('edit_history', { data: newHistory });
            closeModal('edit-history');
            const logTextarea = document.getElementById('log-textarea');
            if (logTextarea) {
                appendAndScroll(logTextarea, "\n--- Agent Memory manually edited by user. ---\n");
            }
        };
    }

    if (editHistoryCloseBtn) {
        editHistoryCloseBtn.onclick = () => closeModal('edit-history');
    }
    if (editHistoryOverlay) {
        editHistoryOverlay.onclick = () => closeModal('edit-history');
    }

    socket.on('initial_state', (data) => {
        // Update local state tracking
        isTaskRunning = data.task_running;

        if(rawLlmTextarea) rawLlmTextarea.value = data.raw_llm_responses;

        // Load the correct view after initial state
        if (historyTextarea) {
            loadAgentMemory();
        }
    });

    socket.on('update_raw_llm_responses', msg => {
        if(rawLlmTextarea) {
            rawLlmTextarea.value = msg.data;
        }
    });

    /**
     * Update view button styles
     */
    const updateViewButtons = () => {
        if (currentView === 'llm_context') {
            if (viewLlmContextBtn) viewLlmContextBtn.style.backgroundColor = '#4CAF50';
            if (viewFullLogBtn) viewFullLogBtn.style.backgroundColor = '#555';
        } else {
            if (viewLlmContextBtn) viewLlmContextBtn.style.backgroundColor = '#555';
            if (viewFullLogBtn) viewFullLogBtn.style.backgroundColor = '#4CAF50';
        }
    };

    /**
     * Load agent memory from API based on current view
     */
    const loadAgentMemory = async () => {
        if (!historyTextarea) return;

        try {
            let endpoint = currentView === 'llm_context' ? '/get_agent_memory_log' : '/get_agent_execution_log';
            const response = await fetch(endpoint);
            const data = await response.json();
            if (data.status === 'success') {
                historyTextarea.value = data.data || 'No data available yet.';
                historyTextarea.scrollTop = historyTextarea.scrollHeight;
            } else {
                historyTextarea.value = `Error: ${data.message || 'Failed to load data'}`;
            }
        } catch (error) {
            console.error('Error loading agent memory:', error);
            historyTextarea.value = 'Error loading data. Please try again.';
        }
    };

    /**
     * Function to actually call API with query and reason
     */
    const executeSearch = async (query, reason) => {
        lastSearchReason = reason;

        if (searchInput) searchInput.value = query;

        if (searchResults) searchResults.style.display = 'block';
        if (searchLoading) searchLoading.style.display = 'block';
        if (searchResultsContainer) searchResultsContainer.style.display = 'none';
        if (addToContextBtn) addToContextBtn.style.display = 'none';
        if (closeSearchResultsBtn) closeSearchResultsBtn.style.display = 'none';

        if (isTaskRunning && executionPausedWarning) {
            executionPausedWarning.style.display = 'block';
        }

        try {
            const response = await fetch(`/search_base_log?q=${encodeURIComponent(query)}&reason=${encodeURIComponent(reason)}`);
            const data = await response.json();

            if (searchLoading) searchLoading.style.display = 'none';
            if (searchResultsContainer) searchResultsContainer.style.display = 'block';
            if (addToContextBtn) addToContextBtn.style.display = 'block';
            if (closeSearchResultsBtn) closeSearchResultsBtn.style.display = 'block';

            if (data.status === 'success') {
                lastSearchResults = data.data || 'No results found.';
                if (searchResultsContent) searchResultsContent.textContent = lastSearchResults;
            } else {
                lastSearchResults = `Error: ${data.message}`;
                if (searchResultsContent) searchResultsContent.textContent = lastSearchResults;
            }
        } catch (error) {
            console.error('Error searching logs:', error);
            if (searchLoading) searchLoading.style.display = 'none';
            if (searchResultsContainer) searchResultsContainer.style.display = 'block';
            lastSearchResults = `Error: ${error.message}`;
            if (searchResultsContent) searchResultsContent.textContent = lastSearchResults;
        }
    };

    const manualSearchModalOverlay = document.getElementById('manual-search-modal-overlay');
    const manualSearchCloseBtn = document.querySelector('.modal-close-btn[data-modal-id="manual-search"]');
    const performSearchBtn = document.getElementById('perform-search-btn');
    const modalSearchQuery = document.getElementById('modal-search-query');
    const modalSearchReason = document.getElementById('modal-search-reason');

    if (searchBtn) {
        searchBtn.addEventListener('click', () => {
            if (modalSearchQuery) modalSearchQuery.value = searchInput ? searchInput.value : '';
            if (modalSearchReason) modalSearchReason.value = '';
            openModal('manual-search');
            if (modalSearchQuery) modalSearchQuery.focus();
        });
    }

    if (searchInput) {
        searchInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                if (modalSearchQuery) modalSearchQuery.value = searchInput.value;
                openModal('manual-search');
                if (modalSearchQuery) modalSearchQuery.focus();
            }
        });
    }

    if (performSearchBtn) {
        performSearchBtn.addEventListener('click', () => {
            const query = modalSearchQuery ? modalSearchQuery.value.trim() : '';
            const reason = modalSearchReason ? modalSearchReason.value.trim() || "User Manual Search" : "User Manual Search";

            if (!query) {
                alert("Please enter a search query.");
                return;
            }

            closeModal('manual-search');
            executeSearch(query, reason);
        });
    }

    if (manualSearchCloseBtn) manualSearchCloseBtn.onclick = () => closeModal('manual-search');
    if (manualSearchModalOverlay) manualSearchModalOverlay.onclick = () => closeModal('manual-search');

    if (refreshHistoryBtn) {
        refreshHistoryBtn.addEventListener('click', () => {
            loadAgentMemory();
            if (searchResults) searchResults.style.display = 'none';
        });
    }

    if (viewLlmContextBtn) {
        viewLlmContextBtn.addEventListener('click', () => {
            currentView = 'llm_context';
            sessionStorage.setItem('historyViewMode', 'llm_context');
            updateViewButtons();
            loadAgentMemory();
        });
    }

    if (viewFullLogBtn) {
        viewFullLogBtn.addEventListener('click', () => {
            currentView = 'full_log';
            sessionStorage.setItem('historyViewMode', 'full_log');
            updateViewButtons();
            loadAgentMemory();
        });
    }

    if (addToContextBtn) {
        addToContextBtn.addEventListener('click', async () => {
            if (!lastSearchResults) {
                alert('No search results to add');
                return;
            }

            const currentQuery = searchInput ? searchInput.value.trim() : '';

            try {
                const response = await fetch('/add_search_to_context', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        query: currentQuery || "User Search",
                        reason: lastSearchReason || "User Manual Search",
                        results: lastSearchResults
                    })
                });

                const data = await response.json();

                if (data.status === 'success') {
                    if (searchResults) searchResults.style.display = 'none';
                    if (executionPausedWarning) executionPausedWarning.style.display = 'none';
                    alert('Search results added to agent context successfully!');
                    loadAgentMemory();
                } else {
                    alert(`Error: ${data.message}`);
                }
            } catch (error) {
                console.error('Error adding search results to context:', error);
                alert(`Error: ${error.message}`);
            }
        });
    }

    if (closeSearchResultsBtn) {
        closeSearchResultsBtn.addEventListener('click', () => {
            if (searchResults) searchResults.style.display = 'none';
            if (executionPausedWarning) executionPausedWarning.style.display = 'none';
        });
    }

    // Listen for task status updates
    socket.on('task_started', () => {
        isTaskRunning = true;
    });

    socket.on('task_finished', () => {
        isTaskRunning = false;
        if (executionPausedWarning) executionPausedWarning.style.display = 'none';

        if (sessionStorage.getItem('isTaskFromChat') === 'true') {
            console.log("Task from chat finished while on History page. Setting pending flag.");
            sessionStorage.setItem('pendingChatAnalysis', 'true');
        }
    });

    socket.on('task_paused', () => {
        console.log("Task paused confirmed.");
    });

    socket.on('update_history', (data) => {
        loadAgentMemory();
    });

    // Initialize view buttons
    updateViewButtons();

});
</script>
{% endblock %}
</body>
</html>

